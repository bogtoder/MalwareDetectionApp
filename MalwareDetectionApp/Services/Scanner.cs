using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Windows;
using MalwareDetectionApp.DTOs;
using MalwareDetectionApp.DTOs.Enums;
using MalwareDetectionApp.Extensions;
using Microsoft.ML;

namespace MalwareDetectionApp.Services
{
    public class Scanner : IDisposable
    {
        private readonly string _backupFilePath;
        private readonly string onnx_model_path = "Model\\model.onnx";

        public List<FileSystemWatcher> watchers;

        public ObservableCollection<UIFileScanResult> PossibleInfected { get; set; } = null!;
        public ObservableCollection<UIFileScanResult> Uninfected { get; set; } = null!;
        public ObservableCollection<string> ExcludedFiles { get; set; } = null!;

        private PredictionEngine<ModelInput, ModelOutput>? predictionEngine;

        public Scanner(
            string backupFilePath,
            ObservableCollection<UIFileScanResult> possibleInfectedFiles,
            ObservableCollection<UIFileScanResult> uninfectedFiles,
            ObservableCollection<string> excludedFiles)
        {
            _backupFilePath = backupFilePath;

            PossibleInfected = possibleInfectedFiles;
            Uninfected = uninfectedFiles;
            ExcludedFiles = excludedFiles;

            watchers = new List<FileSystemWatcher>();

            LoadModel();
        }

        private void LoadModel()
        {
            var mlContext = new MLContext();
            var pipeline = mlContext.Transforms.ApplyOnnxModel(
                modelFile: onnx_model_path,
                outputColumnNames: new[] { "dense_16" },
                inputColumnNames: new[] { "dense_13_input" });

            var model = pipeline.Fit(mlContext.Data.LoadFromEnumerable(new List<ModelInput>()));

            predictionEngine = mlContext.Model.CreatePredictionEngine<ModelInput, ModelOutput>(model);
        }

        public void StartTracking(string targetDirectory)
        {
            FileSystemWatcher watcher = new()
            {
                Path = targetDirectory,
                IncludeSubdirectories = false,
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.LastAccess
            };

            watcher.Changed += OnChanged;
            watcher.Created += OnChanged;
            watcher.EnableRaisingEvents = true;

            watchers.Add(watcher);
        }

        public void ScanFileAndUpdateLists(string filePath)
        {
            var scanResult = ScanFile(filePath);
            var isMalware = scanResult.MaxBy(res => res.Confidence).Malware != MalwareType.None;

            var fileScanResult = new UIFileScanResult
            {
                FilePath = filePath,
                ScanResult = scanResult,
            };

            if (isMalware)
            {
                Application.Current.Dispatcher.Invoke(() =>
                {
                    PossibleInfected.Add(fileScanResult);
                });
            }
            else
            {
                Application.Current.Dispatcher.Invoke(() =>
                {
                    Uninfected.Add(fileScanResult);
                });
            }
        }

        private IEnumerable<(MalwareType Malware, float Confidence)> ScanFile(string filePath)
        {
            if (!File.Exists(filePath)) 
            { 
                throw new Exception($"Cannot find {filePath}.");
            }

            var byteProbsAndEntropy = FeaturesService.GetByteFreqsAndEntropy(filePath) 
                ?? throw new Exception($"Failed to create featurs for file {filePath}.");

            var modelInput = new ModelInput
            {
                ByteHistogram = byteProbsAndEntropy
            };

            var scanResult = predictionEngine!.Predict(modelInput);

            return scanResult.Detections();
        }

        public void ScanDirectory(string targetDirectory)
        {
            if(ExcludedFiles.Contains(targetDirectory)) 
            {
                return;
            }

            var allFiles = Directory.GetFiles(targetDirectory);

            foreach (var file in allFiles)
            {
                if(!ExcludedFiles.Contains(file))
                {
                    var possibleInfected = PossibleInfected.FirstOrDefault(item => item.FilePath == file);
                    var uninfected = Uninfected.FirstOrDefault(item => item.FilePath == file);

                    if (possibleInfected != null)
                    {
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            PossibleInfected.Remove(possibleInfected);
                        });
                    }
                    else if (uninfected != null)
                    {
                        Application.Current.Dispatcher.Invoke(() =>
                        {
                            Uninfected.Remove(uninfected);
                        });
                    }

                    ScanFileAndUpdateLists(file);
                }
            }
        }

        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            if (!File.Exists(e.FullPath)) return;

            if (ExcludedFiles.Contains(e.FullPath)) return;

            var possibleInfected = PossibleInfected.FirstOrDefault(item => item.FilePath == e.FullPath);
            var uninfected = Uninfected.FirstOrDefault(item => item.FilePath == e.FullPath);

            if (possibleInfected != null)
            {
                Application.Current.Dispatcher.Invoke(() =>
                {
                    PossibleInfected.Remove(possibleInfected);
                });
            }
            else if (uninfected != null)
            {
                Application.Current.Dispatcher.Invoke(() =>
                {
                    Uninfected.Remove(uninfected);
                });
            }

            try
            {
                ScanFileAndUpdateLists(e.FullPath);
            }
            catch (Exception)
            {
                throw;
            }
        }

        public void Dispose()
        {
            var streamWriter = File.CreateText(_backupFilePath);

            foreach (var file in PossibleInfected)
            {
                streamWriter.Write(file.ToString());
            }
            foreach (var file in Uninfected)
            {
                streamWriter.Write(file.ToString());
            }

            streamWriter.Close();
            streamWriter.Dispose();
        }
    }
}
